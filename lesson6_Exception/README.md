## ‚ö° Exception Entry

1) Set the pending bit.  
2) Stacking and Vector fetch.  
3) Entry in handler mode and set active bit.  
4) Clears the pending status (processor does it automatically).  
5) Processor mode changed to handler mode.  
6) Handler code starts executing.  
7) MSP used for any stack operations inside handler.

---

## üîÑ Exit Sequence

1) In Cortex processors, the exception return mechanism is triggered using a special return address called **EXC_RETURN**.  
2) EXC_RETURN is generated during entry and stored in **LR (Link Register)**.  
3) When EXC_RETURN is written to **PC**, it triggers the exception return.  
4) During exception handler entry, the return address is not stored in LR like in a normal C function call.  
   Instead, the exception mechanism stores a special value called **EXC_RETURN** in LR.

---

## üîç Decoding EXC_RETURN Value

1) **Bit 2 and Bit 3** are used as return stack and return mode, respectively.  
   - Bit 3 ‚Üí Thread mode = 1, Handler mode = 0  
   - Bit 2 ‚Üí PSP return = 1, MSP return = 0  

2) What happens when an exception triggers:  
   - If bit 2 = 0 ‚Üí Unstacking done by **MSP**. MSP selected ‚Üí CONTROL[1] = 0 ‚Üí Resume program execution.  
   - If bit 2 = 1 ‚Üí Unstacking done by **PSP**. PSP selected ‚Üí CONTROL[1] = 1 ‚Üí Resume program execution.

---

## üö® Fault Handlers

Fault exception is generated by processor to indicate an error.  
Reasons of fault:

1) Because of programmer‚Äôs handling of processor by violating design rules or due to interfaces processor deals with.  
2) When a fault happens, internal processor registers update to record the type of fault, the address of the instruction where the fault occurred, and if an associated exception is enabled, the exception handler will be called.  
3) In exception handler, programmers may implement code to report, resolve, or recover from the fault (e.g., divide by 0).  
4) Reset, NMI, HardFault are such exceptions which are **non-configurable** and fixed in priority.  
5) Fault exceptions include Hard Fault, MemManage Fault, BusFault, Usage Fault.  
6) Hard fault exceptions can be disabled using **fault mask register**.

---

## üí• Real Problems of Fault

1) Divide by zero and undefined instructions.  
2) Attempt to execute code from memory marked as *execute never* (security protection from code injection).  
3) MPU-guarded memory access violation and unaligned data access.  
4) Returning to thread mode while an active interrupt is still running, causing bus error.  
5) Executing SVC instruction inside SVC handler, or calling a function inside SVC handler that executes a hidden SVC instruction.  
6) Debug monitor settings and related exceptions.

---

## üõë Hard Fault Exception

Occurs because of an error during exception processing or exception not handled by other mechanisms.  

Causes:  
1) Escalation of configurable fault exceptions.  
2) Bus error returned during vector fetch.  
3) Execution of breakpoint instruction when both halt mode and debug monitor are disabled.  
4) Executing SVC instruction inside SVC handler.  
5) Any configurable exception not enabled gets escalated to HardFault.

---

## üß± MemManage Fault Exception

1) Configurable fault exception, disabled by default.  
2) Can be enabled by configuring processor register **System Handler Control and State Register**.  
3) Priority also configurable.  

Causes:  
1) Detected when memory access violation occurs ‚Äî e.g., unprivileged thread mode trying to access privileged memory.  
2) Writing to read-only memory. Triggered especially when executing code from peripheral memory regions (execute-never).  

Execute-Never regions include:  
- Peripheral  
- External RAM  
- External device  
- PPB, etc.

---

## üöå Bus Fault

Causes:  
1) Due to error response returned by processor bus interfaces during memory access (fetch or read/write).  
2) If bus error happens during vector fetch ‚Üí escalated to HardFault (even if BusFault is enabled).  
3) Memory device sends error response when processor accesses invalid or restricted memory ‚Üí results in BusFault.  
4) When device is not ready to accept memory transfer.  
5) Common when working with external memories like **SDRAM** via DRAM controllers.  
6) Unprivileged access to PPB.

---

## ‚öôÔ∏è Usage Fault

Causes:  
1) Execution of undefined instructions (e.g., unsupported ARM ISA instructions).  
2) Executing floating instructions without FPU while T bit = 0.  
3) Returning to thread mode while still executing an exception.  
4) Unaligned memory access with multiple load/store instructions.  
5) Divide-by-zero and unaligned data access from memory.

---
